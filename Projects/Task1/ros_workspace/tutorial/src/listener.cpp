#include "ros/ros.h"
#include "std_msgs/String.h"
#include <map>
#include <fstream>

/**
* Этот пример демонстрирует простое получение сообщений в системе ROS.
*/
std::map<float, int> myMap;
void chatterCallback(const std_msgs::String::ConstPtr& msg)
{
    ROS_INFO("I heard: [%s]", msg->data.c_str());
    float ftemp = atof(msg->data.c_str());
    if (myMap.find(ftemp) == myMap.end()) {
        myMap[ftemp] = 1;
    } else {
        myMap[ftemp] += 1;
    }
}
int main(int argc, char **argv)
{
    /**
* Функция ros::init() требуется для проверки аргументов argc и argv, чтобы выполнить* преобразования или переопределение аргументов ROS, задаваемых через командную строку.
* Для программного переопределения вы можете использовать другую версию init(), которая
* принимает переопределение напрямую, но для большинства программ командной сроки, обработка
* argc и argv - простейший путь реализовать это. Третий аргумент init() - это название узла.
*
* Вы должны вызвать одну из версий ros::init() перед использованием любых других
* частей системы ROS.
*/
    ros::init(argc, argv, "listener");
    /**
* NodeHandle - главная точка доступа для взаимодействия с системой ROS.
* Конструктор NodeHandle полностью инициализирует этот узел, а в конце,
* деструктор NodeHandle завершит работу узла.
*/
    ros::NodeHandle n;
    /**
* subscribe() сообщает ROS, что вы хотите получать сообщения
* на заданную тему. Это приводит к запросу Мастер-узла ROS,
* который содержит регистрационные данные о том, кто публикуте и
* кто получает сообщения. Сообщения передаются в функцию обратного вызова, здесь
* она называется chatterCallback. subscribe() возвращает объект подписчика(Subscriber), который вы
* должны держать, пока вы не захотите отказаться от подписки. Когда все копии объекта подписки
* выходят из области видимости, то обратный вызов будет автоматически отписан от
* этой темы.
*
* Второй параметр subscribe() указывает размер очереди сообщений.
* Если сообщения прибывают быстрее, чем они обрабатываются, это
* число указывает количество сообщений, которые будут сохраняться
* в буфере прежде чем удалять самые старые.
*/
    ros::Subscriber sub = n.subscribe("chatter", 1000, chatterCallback);
    /**
* ros::spin() будет входить в цикл, прокачки обратных вызовов. В этой версии, все
* обратные вызовы будут вызвана из этой нити (основноой).
* ros::spin() будет завершён после нажатия Ctrl-C, или отключения узла от мастера.
*/
    ros::spin();
    std::ofstream file ("output.txt", std::ofstream::out);
    for (std::map<float, int>::iterator it=myMap.begin(); it!=myMap.end(); ++it)
        file << it->first << " => " << it->second << '\n';
    file.close();
    return 0;
}
